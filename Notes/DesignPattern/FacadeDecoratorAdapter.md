# Facade Pattern 外观模式

1. 概念
   Facade Pattern（外观模式） 是一种结构型设计模式，用于简化复杂系统的使用。它提供一个统一的接口（Facade），封装子系统的复杂逻辑，使客户端无需直接与多个子系统交互，而是通过一个简单的入口进行操作。

2. 主要特点
   简化接口：隐藏子系统的复杂性，对外提供更简单的 API。
   降低耦合：客户端不需要了解子系统的内部实现，依赖于 Facade，而不是多个子系统。
   提升可维护性：修改子系统时，不影响客户端代码，只需调整 Facade 内部逻辑。

3. 使用场景
   提供统一接口：当系统包含多个子模块，客户端只需调用一个接口来访问它们。
   降低依赖：当多个子系统之间高度耦合，Facade 可以隔离变化，防止影响客户端。
   简化调用逻辑：适用于需要隐藏底层实现、减少 API 复杂度的情况。

   “一键启动 xx 模式”，本质上是用一个 API 封装了内部子模块的一系列 api call - 只封装接口，不改变子系统。

- Facade Pattern 适用于：隐藏复杂子系统、简化 API 调用、降低耦合。
- 优点：
  使客户端代码更简单，降低学习成本。
  使子系统更灵活，方便维护和扩展。
  降低模块之间的依赖，提高系统稳定性。
- 缺点：
  可能导致单一入口变得过于庞大，需要合理拆分多个 Facade。
  可能隐藏过多细节，使某些高级功能难以访问。

# Decorator Pattern 装饰器模式

1. 概念
   Decorator Pattern（装饰器模式） 是一种结构型设计模式，用于动态地扩展对象的功能，而不改变其原始代码或使用继承。

它通过将对象包装在装饰器类中，在运行时增强对象的行为，使功能可以按需组合，避免继承导致的类爆炸问题。（咖啡厅饮料装 toppings）

2. 主要特点
   动态扩展对象的功能，不修改原始类。
   比继承更灵活，可以组合多个装饰器。
   遵循开闭原则（OCP），可以增加功能而不修改已有代码。

3. Example 咖啡订单系统
   假设一个咖啡店，基础饮料有 Espresso（浓缩咖啡） 和 Latte（拿铁），可以添加 Milk（牛奶）、Sugar（糖）、Whip（奶泡） 等配料。
   如果使用继承，每种组合都需要一个子类，导致类爆炸。

使用装饰器模式，我们可以用动态包装（Wrapper）的方式，给咖啡按需增加不同的配料，而不用创建无数个子类。

=== 设计关键点 ===
CondimentDecorator 作为抽象装饰器泪，不直接实现 Beverage 的所有方法，而是让具体装饰器去实现 getDescription() 方法。

- CondimentDecorator 只是一个 抽象装饰器，它本身不应该定义具体的行为，而是作为基类，让具体的装饰器类（如 Milk、Sugar）去实现这些行为。

- CondimentDecorator implements Beverage，是为了保证所有装饰器和被装饰的对象有相同的接口，这样装饰器才能互相嵌套（即可以多层装饰）。
- 但是 CondimentDecorator 不能确定具体的装饰行为，比如 "牛奶" 和 "糖" 的价格不同，描述（description）也不同，所以它不直接实现 getDescription() 和 cost()，而是留给子类去实现。

- CondimentDecorator 不实现 getDescription() 和 cost()，而是留给子类实现，是为了让装饰器具备动态扩展功能**，否则就失去了装饰器模式的意义。**

🎯 这就是装饰器模式的核心思想： "让装饰器对原对象进行增量修改，而不影响原始对象的结构"。
