# Saga Pattern

- Saga 模式用于维护分布式系统中的数据一致性。由于传统的数据库事务（ACID）不适用于微服务，Saga 通过一系列补偿事务来管理长时间运行的事务。 Saga patterns are used to maintain data consistency across multiple services in a distributed system

## Orchestration-Based Saga

- 由一个 Saga 编排器（Saga Orchestrator）控制事务流程。
- 编排器依次调用每个微服务，确保整个事务的执行顺序。
- 服务之间不会直接通信，所有指令都由编排器下达。
- 优点：流程清晰，易于管理；
- 缺点：单点控制，依赖编排器。
- 示例：Saga 编排器依次指挥 订单服务 → 支付服务 → 库存服务 进行操作，并处理失败情况。

## Choreography-Based Saga

- 每个微服务都监听来自其他服务的事件，并在收到事件后执行自己的事务。
- 事务由多个服务的事件流驱动，无中央控制。
- 优点：去中心化，减少单点故障；
- 缺点：多个服务间的事件依赖会导致流程复杂，难以管理。
- 示例：订单服务创建订单后，发布**“订单创建”事件**，支付服务监听该事件并执行支付，再发布**“支付完成”事件**，库存服务再监听支付事件并更新库存。

## Compensating Transactions 补偿机制

由于没有分布式事务机制，如果某个步骤失败，需要通过补偿事务撤销之前的操作：

示例：订单已创建，但支付失败，则触发订单取消操作。

# Use case

1. 分布式系统中需要保证最终一致性
2. 事务涉及多个微服务，存在长时间运行操作
3. 需要应对 partial failure 并进行回滚 rollback

# CQRS Command Query Responsibility Segregation 命令查询职责分离

- 架构模式，旨在分离数据的写操作 Command 和读操作 Query，提高系统的可扩展性、性能和维护性。

🔹 传统架构：

- 读写共享同一数据模型，导致查询性能下降，影响写入操作。

🔹 CQRS 架构：

- 写库（Write Model） 处理命令，执行业务逻辑，并持久化数据。
- 读库（Read Model） 通过事件或数据同步机制，维护一个专门优化查询的模型（例如，使用缓存、NoSQL 数据库等）。
- 事件总线（Event Bus，可选） 处理命令执行后的数据同步，使读库保持最新状态。

🚀 高读写分离需求：当系统读多写少（或写多读少）时，CQRS 可以优化性能。
🚀 复杂业务逻辑：当写入操作涉及复杂的事务、权限校验等，CQRS 可以解耦逻辑。
🚀 微服务架构：CQRS 适合微服务，实现独立的读写服务，提高数据一致性和可扩展性。
